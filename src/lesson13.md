# 课时十三：树

> **考点分布**
> 
> | 考点 | 重要程度 | 分值 | 题型 |
> |------|---------|------|------|
> | 1. 无向树及其性质 | ★★★★ | 4 ~ 6 | 选择、填空、判断 |
> | 2. 最小生成树 | ★★★★★ | 0 ~ 6 | 解答 |
> | 3. 根树及其应用 | 🔥必考 | 10 ~ 12 | 解答 |

---

## 1. 无向树及其性质

### 📖 基本概念

**无向树（树）**：连通无回路的无向图称作**无向树**，或简称为**树**。

**树叶**：在无向树中，度数等于1的顶点称作**树叶**。

**分支点**：在无向树中，度数大于等于2的顶点称作**分支点**。

### 💡 树的等价定义

设 \\(G = \\langle V, E \\rangle\\) 是 \\(n\\) 阶 \\(m\\) 条边的无向图，则下列各命题是等价的：

1. \\(G\\) 是树
2. \\(G\\) 中任意两个顶点之间存在唯一的路径
3. \\(G\\) 是无回路且 \\(m = n - 1\\)
4. \\(G\\) 是连通的且 \\(m = n - 1\\)

**重要性质**：设 \\(T\\) 是 \\(n\\) 阶非平凡的无向树，则 \\(T\\) 中至少有两片树叶。

### 📝 例题

**例题1**：无向简单图是棵树，当且仅当（ ）。

A. \\(G\\) 连通并且边数比节点数少1

B. \\(G\\) 连通并且节点数比边数少1

C. \\(G\\) 的边数比节点数少1

D. \\(G\\) 中没有回路

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**树的等价定义**：\\(G\\) 是树当且仅当 \\(G\\) 是连通的且 \\(m = n - 1\\)

**选项A**：\\(G\\) 连通并且边数比节点数少1
- 即：连通且 \\(m = n - 1\\) ✅ 正确

**选项B**：\\(G\\) 连通并且节点数比边数少1
- 即：连通且 \\(n = m - 1\\)，即 \\(m = n + 1\\) ❌ 错误

**选项C**：\\(G\\) 的边数比节点数少1
- 只说了 \\(m = n - 1\\)，没有说连通 ❌ 错误

**选项D**：\\(G\\) 中没有回路
- 只说了无回路，没有说连通 ❌ 错误

**答案**：A

</details>

---

**例题2**：边数等于节点数减1的无向图是树。（）

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**错误** ❌

**说明**：
- 树需要：连通 + 无回路 + \\(m = n - 1\\)
- 只满足 \\(m = n - 1\\) 不一定连通，所以不一定是树

**反例**：两个分离的树，边数 = (n₁ - 1) + (n₂ - 1) = (n₁ + n₂) - 2 = n - 2，不满足条件。

更好的反例：一个连通图但有多余边的图，不满足条件。

实际上，如果只满足 \\(m = n - 1\\)，图可能不连通，所以不一定是树。

**答案**：错误

</details>

---

**例题3**：设 \\(G\\) 是5个顶点的完全图，则从 \\(G\\) 中删除（ ）条边可以得到树。

A. 4

B. 5

C. 6

D. 10

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**5个顶点的完全图 \\(K_5\\) 的边数**：
\\[
\\frac{5 \\times (5-1)}{2} = \\frac{5 \\times 4}{2} = 10
\\]

**5个顶点的树的边数**：\\(5 - 1 = 4\\)

**需要删除的边数**：\\(10 - 4 = 6\\)

**答案**：C

</details>

---

**例题4**：一棵树有两个2度顶点，1个3度顶点和3个4度顶点，则1度顶点数为（ ）。

A. 5

B. 7

C. 9

D. 8

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**设1度顶点数为 \\(t\\)**

**总顶点数**：\\(n = t + 2 + 1 + 3 = t + 6\\)

**总边数**（树的性质）：\\(m = n - 1 = t + 5\\)

**使用握手定理**：
\\[
\\sum d(v) = 1 \\times t + 2 \\times 2 + 3 \\times 1 + 4 \\times 3 = t + 4 + 3 + 12 = t + 19
\\]

\\[
t + 19 = 2m = 2(t + 5) = 2t + 10
\\]

\\[
t + 19 = 2t + 10 \\Rightarrow t = 9
\\]

**答案**：C

</details>

---

## 2. 最小生成树

### 📖 基本概念

**子图**：设 \\(G = \\langle V,E \\rangle\\)，\\(G' = \\langle V',E' \\rangle\\) 为两个图，若 \\(V' \\subseteq V\\) 且 \\(E' \\subseteq E\\)，则称 \\(G'\\) 为 \\(G\\) 的**子图**。

**生成子图**：若 \\(V' = V\\)，则称 \\(G'\\) 为 \\(G\\) 的**生成子图**。

**生成树**：如果无向图 \\(G\\) 的生成子图 \\(T\\) 是树，则称 \\(T\\) 是 \\(G\\) 的**生成树**。

**生成树的存在性**：无向图 \\(G\\) 有生成树当且仅当 \\(G\\) 是连通图。

**最小生成树**：设无向连通带权图 \\(G = \\langle V, E, W \\rangle\\)，\\(T\\) 是 \\(G\\) 的一棵生成树，\\(T\\) 的各边权之和称为 \\(T\\) 的**权**，记作 \\(W(T)\\)。\\(G\\) 的所有生成树中权最小的生成树称为 \\(G\\) 的**最小生成树**。

### 💡 最小生成树算法（Kruskal算法）

**步骤**：
1. 给所有边按权从小到大排序
2. 初始化：描点，将边数置零
3. 选边：选择权最小且不构成回路的边
4. 重复步骤3，直到边数 = 顶点数 - 1

### 📝 例题

**例题1**：设赋权无向连通图 \\(G\\) 如下，求 \\(G\\) 的最小生成树，并求该最小生成树的权总和。

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**使用Kruskal算法**：

**步骤1**：给权排序：1, 2, 3, 3, 4, 5, 5, 5, 6, 6

**步骤2**：初始化：描点，边数 = 0

**步骤3**：选边（权最小，且不构成回路）：
- 选权为1的边
- 选权为2的边
- 选权为3的边（第一个）
- 选权为3的边（第二个）
- 选权为5的边（不构成回路）

**步骤4**：边数 = 5 = 6 - 1，结束

**最小生成树的权**：
\\[
W(T) = 1 + 2 + 3 + 3 + 5 = 14
\\]

**答案**：最小生成树的权总和为14

</details>

---

## 3. 根树及其应用 🔥必考重点

### 📖 基本概念

**有向树**：若有向图的基图是无向树，则称这个有向图为**有向树**。

**根树**：一个顶点的入度为0，其余顶点的入度为1的有向树称作**根树**。入度为0的顶点称作**树根**。

**层数**：从树根到任意顶点 \\(v\\) 的路径长度（即路径中的边数）称作 \\(v\\) 的**层数**。

**祖先与后代**：设 \\(T\\) 为一棵非平凡的根树，\\(\forall v_i, v_j \\in V(T)\\)，若 \\(v_i\\) 可达 \\(v_j\\)，则称 \\(v_i\\) 为 \\(v_j\\) 的**祖先**，\\(v_j\\) 为 \\(v_i\\) 的**后代**。

**父亲与儿子**：若 \\(v_i\\) 邻接到 \\(v_j\\)（即 \\(\\langle v_i, v_j \\rangle \\in E(T)\\)），则称 \\(v_i\\) 为 \\(v_j\\) 的**父亲**，而 \\(v_j\\) 为 \\(v_i\\) 的**儿子**。

**兄弟**：若 \\(v_j\\) 和 \\(v_k\\) 的父亲相同，则称 \\(v_j\\) 与 \\(v_k\\) 是**兄弟**。

**\\(r\\) 叉树**：若 \\(T\\) 的每个分支点至多有 \\(r\\) 个儿子，则称 \\(T\\) 为**\\(r\\) 叉树**。

**二叉树**：每个分支点至多有2个儿子的根树称作**二叉树**。

### 💡 最优二叉树（Huffman树）

**带权二叉树的权**：设二叉树 \\(T\\) 有 \\(t\\) 片树叶 \\(v_1, v_2, \\ldots, v_t\\)，权分别为 \\(w_1, w_2, \\ldots, w_t\\)，称：

\\[
W(T) = \\sum_{i=1}^{t} w_i l(v_i)
\\]

为 \\(T\\) 的**权**，其中 \\(l(v_i)\\) 是 \\(v_i\\) 的层数。

**最优二叉树**：在所有有 \\(t\\) 片树叶、带权 \\(w_1, w_2, \\ldots, w_t\\) 的二叉树中，权最小的二叉树称作**最优二叉树**。

**Huffman算法**：
1. 将 \\(t\\) 个权按从小到大排序
2. 取两个最小的权，构造一个新节点，其权为这两个权的和
3. 将新节点的权加入序列，重复步骤2，直到只剩一个节点

### 📖 前缀码

**前缀**：设 \\(\\alpha_1\\alpha_2\\ldots\\alpha_{n-1}\\alpha_n\\) 是长为 \\(n\\) 的符号串，称其子串 \\(\\alpha_1, \\alpha_1\\alpha_2, \\ldots, \\alpha_1\\alpha_2\\ldots\\alpha_n\\) 为该符号串的**前缀**。

**前缀码**：设 \\(A = \\{\\beta_1, \\beta_2, \\ldots, \\beta_n\\}\\) 是一个符号串集合，若 \\(A\\) 的任意两个符号串都互不为前缀，则称 \\(A\\) 为**前缀码**。

**2元前缀码**：由0-1符号串构成的前缀码称作**2元前缀码**。

**最佳前缀码**：由最优二叉树产生的前缀码为**最佳前缀码**。

### 📝 例题

**例题1**：用算法Huffman计算一组权为2,3,5,7,11,13,17的最优二叉树，并求它们的权值。

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**使用Huffman算法**：

**步骤**：
1. 排序：2, 3, 5, 7, 11, 13, 17
2. 取最小的两个：2, 3 → 新节点5（权为5）
3. 序列变为：5, 5, 7, 11, 13, 17
4. 取最小的两个：5, 5 → 新节点10（权为10）
5. 序列变为：7, 10, 11, 13, 17
6. 取最小的两个：7, 10 → 新节点17（权为17）
7. 序列变为：11, 13, 17, 17
8. 取最小的两个：11, 13 → 新节点24（权为24）
9. 序列变为：17, 17, 24
10. 取最小的两个：17, 17 → 新节点34（权为34）
11. 序列变为：24, 34
12. 取最小的两个：24, 34 → 新节点58（权为58）

**计算权值**：
\\[
W(T) = 5 \\times 2 + 5 \\times 3 + 4 \\times 5 + 3 \\times 7 + 2 \\times 11 + 2 \\times 13 + 2 \\times 17 = 148
\\]

或：\\(5 + 10 + 17 + 34 + 58 + 24 = 148\\)

**答案**：最优二叉树的权值为148

</details>

---

**例题2**：下面给出的符号串集合中，构成前缀码的是（ ）。

A. \\(\\{b, c, aa, ac, aba, abb, aaa\\}\\)

B. \\(\\{b, c, a, aa, ac, aba, abb, abc\\}\\)

C. \\(\\{b, c, aa, ac, aba, abb, adc\\}\\)

D. \\(\\{b, c, aa, ac, aba, abb, aac\\}\\)

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**前缀码的定义**：任意两个符号串都互不为前缀

**检查每个选项**：

**选项A**：\\(\\{b, c, aa, ac, aba, abb, aaa\\}\\)
- \\(aa\\) 是 \\(aaa\\) 的前缀 ❌

**选项B**：\\(\\{b, c, a, aa, ac, aba, abb, abc\\}\\)
- \\(a\\) 是 \\(aa\\), \\(ac\\), \\(aba\\), \\(abb\\), \\(abc\\) 的前缀 ❌

**选项C**：\\(\\{b, c, aa, ac, aba, abb, adc\\}\\)
- 检查所有对：
  - \\(b, c, aa, ac, aba, abb, adc\\) 两两互不为前缀 ✅

**选项D**：\\(\\{b, c, aa, ac, aba, abb, aac\\}\\)
- \\(aa\\) 是 \\(aac\\) 的前缀 ❌

**答案**：C

</details>

---

## 4. 练习题

### 练习1

下面哪一种图不一定是树（ ）。

A. 无回路的连通图

B. 有 \\(n\\) 个顶点 \\(n - 1\\) 条边的连通图

C. 每对顶点之间都有通路的图

D. 连通但删去一条边则不连通的图

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**树的等价定义**：
- 连通 + 无回路
- 连通 + \\(m = n - 1\\)

**选项A**：无回路的连通图
- 连通 + 无回路 = 树 ✅

**选项B**：有 \\(n\\) 个顶点 \\(n - 1\\) 条边的连通图
- 连通 + \\(m = n - 1\\) = 树 ✅

**选项C**：每对顶点之间都有通路的图
- 这是连通图的定义，但可能有回路 ❌

**选项D**：连通但删去一条边则不连通的图
- 这是树的定义（极小连通图）✅

**答案**：C

</details>

---

### 练习2

\\(n\\) 阶非平凡的无向树至少有（ ）片树叶。

A. 2

B. 3

C. 4

D. 5

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**重要性质**：设 \\(T\\) 是 \\(n\\) 阶非平凡的无向树，则 \\(T\\) 中至少有两片树叶。

**答案**：A

</details>

---

### 练习3

设图 \\(G\\) 是有6个顶点的连通图，总度数为20，则从 \\(G\\) 中删去（ ）条边后使之变成树。

A. 10

B. 5

C. 3

D. 2

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**使用握手定理**：
\\[
\\sum d(v) = 20 = 2m \\Rightarrow m = 10
\\]

**6个顶点的树的边数**：\\(m_T = 6 - 1 = 5\\)

**需要删除的边数**：\\(10 - 5 = 5\\)

**答案**：B

</details>

---

### 练习4

一颗无向树 \\(T\\) 有5片树叶，3个2度分支点，其余的分支都是3度顶点，则 \\(T\\) 有\\underline{\\quad}个顶点。

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**设3度分支点有 \\(x\\) 个**

**总顶点数**：\\(n = 5 + 3 + x = 8 + x\\)

**总边数**（树的性质）：\\(m = n - 1 = 7 + x\\)

**使用握手定理**：
\\[
\\sum d(v) = 1 \\times 5 + 2 \\times 3 + 3 \\times x = 5 + 6 + 3x = 11 + 3x
\\]

\\[
11 + 3x = 2m = 2(7 + x) = 14 + 2x \\Rightarrow x = 3
\\]

**总顶点数**：\\(n = 8 + 3 = 11\\)

**答案**：11

</details>

---

### 练习5

无向图 \\(G\\) 具有生成树，当且仅当\\underline{\\quad}。

<details>
<summary><strong>点击查看答案</strong></summary>

**解答**：

**生成树的存在性**：无向图 \\(G\\) 有生成树当且仅当 \\(G\\) 是连通图。

**答案**：\\(G\\) 是连通图

</details>

---

## 📌 总结

### 关键要点

1. **树的性质**：
   - 连通 + 无回路
   - 连通 + \\(m = n - 1\\)
   - \\(n\\) 阶非平凡树至少有两片树叶

2. **生成树**：
   - 存在条件：图是连通图
   - 最小生成树：权最小的生成树

3. **根树**：
   - 一个顶点入度为0（树根），其余顶点入度为1
   - 最优二叉树：使用Huffman算法

4. **前缀码**：
   - 任意两个符号串互不为前缀
   - 由最优二叉树产生的前缀码为最佳前缀码

### 记忆技巧

- **树的边数**：\\(m = n - 1\\)
- **树的叶子**：至少2片
- **最小生成树**：Kruskal算法（权最小，不构成回路）
- **Huffman算法**：每次取两个最小的权合并
